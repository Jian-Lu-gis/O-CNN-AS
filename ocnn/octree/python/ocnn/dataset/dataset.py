"""Module definining class to create datasets"""

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

from collections import defaultdict
import os

import numpy as np

from ocnn.utils.file_utils import dump_dictionary
from ocnn.dataset.ordered_producer_consumer import OrderedProducerConsumer

class Dataset:
    """Class to create datasets"""

    SPLITS = ('train', 'test', 'val')
    LABEL_MAP_FILE_NAME = 'label_map.txt'

    def __init__(self, dataset_structure):
        """ Initialzes Dataset
        Args:
          dataset_structure: DatasetStructure object.
        """
        self.dataset_structure = dataset_structure
        self.data_processor = None
        self.builder = None

    def _consume_function(self, item):
        """ Consume function used by builder object.
        Args:
          item : Tuple of WritableData and data label. To be consumed by
            builder object.
        """
        produced_data, label = item
        self.builder.add_data(produced_data, label)

    def _produce_function(self, item):
        """ Produce function used by data processor object
        Args:
          item: Tuple of file_path, label, and augmentation index of dataset
          object.
        """
        file_path, label, aug_idx = item
        writable_data = self.data_processor.process(file_path, aug_idx)

        return (writable_data, label)

    def _generate_class_label_map(self, dataset_map):
        """ Iterates through dataset splits and merges classes to create a map
        between class label and an class label index.

        Args:
          dataset_map: Dataset map items generated by DatasetStructure.
        """
        class_set = set()
        for split in dataset_map:
            split_class_set = set(dataset_map[split].keys())
            class_set = class_set.union(split_class_set)
        return dict(zip(class_set, range(len(class_set))))

    def produce_dataset(self, data_processor, builder, output_folder, num_threads=8):
        """ Produces dataset
        Args:
          data_processor: DataProcessor object.
          builder: Builder object.
          output_folder: Folder to output dataset.
          num_threads: Number of worker threads to generate dataset.
        """

        self.data_processor = data_processor
        self.builder = builder

        dataset_map = {split: defaultdict(list) for split in Dataset.SPLITS}

        for split, class_type, path in self.dataset_structure.generate_class_map():
            dataset_map[split][class_type].append(path)

        class_label_map = self._generate_class_label_map(dataset_map)

        dump_dictionary(
            dictionary=class_label_map,
            output_path=os.path.join(output_folder, Dataset.LABEL_MAP_FILE_NAME))

        for split in dataset_map:
            class_model_map = dataset_map[split]
            if class_model_map:
                self.builder.open(os.path.join(output_folder, 'db_') + split)

                class_position_cumsum = np.cumsum([len(x) * self.data_processor.num_aug for x in class_model_map.values()], dtype=np.int64)
                permutation_sequence = np.random.permutation(class_position_cumsum[-1])
                class_list = list(class_model_map.keys())

                with OrderedProducerConsumer(num_threads,
                                             self._produce_function,
                                             self._consume_function) as pc:
                    for permutation_idx in permutation_sequence:
                        prev_sum = 0
                        for idx, cur_sum in enumerate(class_position_cumsum):
                            if permutation_idx < cur_sum:
                                class_type = class_list[idx]
                                break
                            prev_sum = cur_sum
                        shift_idx = permutation_idx - prev_sum
                        model_idx = int(shift_idx / self.data_processor.num_aug)
                        aug_idx = shift_idx % self.data_processor.num_aug
                        file_path = class_model_map[class_type][model_idx]
                        pc.put((file_path, class_label_map[class_type], aug_idx))

                self.builder.close()
